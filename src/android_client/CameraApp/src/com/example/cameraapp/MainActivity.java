package com.example.cameraapp;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;

import android.support.v7.app.ActionBarActivity;
import android.content.pm.ActivityInfo;
import android.graphics.ImageFormat;
import android.hardware.Camera;
import android.hardware.Camera.Size;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.SurfaceHolder;
import android.view.SurfaceHolder.Callback;
import android.view.SurfaceView;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;


public class MainActivity extends ActionBarActivity {

	int CONTROL_SYNCH = 55;
	int CONTROL_CAM = 0;
	int CONTROL_CLOSE = 1;
	int CAM_QUEUE_MAX = 9;
	int CONTROL_SIZE = 24;
	String ip_address = "45.79.163.50";		// Server's IP Address.
	int port = 7356;						// Server's Port.
//	String ip_address = "10.103.224.253";	// Server's IP Address.
//	int port = 27015;						// Server's Port.
	Button connect_button;					// Button for connecting and disconnecting to server.
	Thread client_thread;					// Thread for running the client netcode.
	Handler handler;						// Handler to ensure text changes on the button only occur on the main thread.
	Socket socket;							// The socket is used to connect to the server.
	Camera camera;							// The camera video is transferred through the socket.
	HandlerThread camera_thread;			// A separate event looper runs the camera preview for optimal performance.
	Handler camera_handler;					// Schedules events on the camera's event looper.
	SurfaceView video_surface;				// Displays the video feed.
	ConcurrentLinkedQueue<byte[]> cam_queue;// Synchronized queue necessary to pass data between threads.
	volatile boolean disconnect_socket;
	
    @SuppressWarnings("deprecation")
	@Override
    protected void onCreate(Bundle savedInstanceState) {
    	
    	// Configurations automatically generated by the ADK.
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        // We want to ensure the orientation doesn't screw up the program.
        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
        
        // Data must be safely passed between threads.
        cam_queue = new ConcurrentLinkedQueue<byte[]>();
        
        // The video surface displays the live video feed transmitted to the server.
        video_surface = (SurfaceView)findViewById(R.id.video_capture_surface);
        final SurfaceHolder video_holder = video_surface.getHolder();
        video_holder.addCallback(new Callback() {
            public void surfaceDestroyed(SurfaceHolder holder) {
            }
            public void surfaceCreated(SurfaceHolder holder) {
            	start_video(holder); // The camera must be started during the call to surfaceCreated.
            }
            public void surfaceChanged(SurfaceHolder holder, int format,
                    int width, int height) {
            }
        });
        
        // Create event looper over which to run the camera.
        camera_thread = new HandlerThread("Camera Thread");
        camera_thread.start();
        camera_handler = new Handler(camera_thread.getLooper());
        
        // Create handler and initialize the socket to null.
        handler = new Handler();
        socket = null;
        disconnect_socket = false;
        
        // Configure the button.
        connect_button = (Button)findViewById(R.id.connect_button);
        connect_button.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (socket==null) {
					socket = new Socket();
					client_thread = new Thread(new Runnable() {
						@Override
						public void run() {
							try {
								
								// Try to connect to server.
								socket.connect(new InetSocketAddress(ip_address, port), 1000);
								handler.post(new Runnable() {
									@Override
									public void run() {
										connect_button.setText("Connection Made!");
									}
								});
								
								// Clear the queue and wait for the control
								// and data arrays.
								try {
									cam_queue.clear();
									OutputStream out = socket.getOutputStream();
									disconnect_socket = false;
									while (disconnect_socket==false) {
										byte[] control = cam_queue.poll();
										if (control!=null) {
											byte[] data;
											while (true) {
												data = cam_queue.poll();
												if (data!=null) {
													break;
												}
											}
											out.write(control);
											out.write(data);
										}
										
									}
								} catch (IOException e) {
									handler.post(new Runnable() {
										@Override
										public void run() {
											connect_button.setText("Something Broke!");
										}
									});
									e.printStackTrace();
								}
								// Real work
								socket.close();
								handler.post(new Runnable() {
									@Override
									public void run() {
										connect_button.setText("Connection Closed!");
									}
								});
								
							} catch (IOException e) {
								handler.post(new Runnable() {
									@Override
									public void run() {
										connect_button.setText("Connection Failed!");
									}
								});
								e.printStackTrace();
							}
							socket = null;
						}
					});
					client_thread.start();
				} else {
					disconnect_socket = true;
				}
	        }
        });
    }

    public void start_video(final SurfaceHolder video_holder) {
    	camera_handler.post(new Runnable() {
			@Override
			public void run() {
				
				// Open and configure the camera.
				camera = Camera.open();
		        Camera.Parameters camera_params = camera.getParameters();
				List<Integer> supported_framerates = camera_params.getSupportedPreviewFrameRates();
		        camera_params.setPreviewFrameRate(supported_framerates.get(0));
		        camera_params.setPreviewFormat(ImageFormat.NV21);
		        List<Size> supported_sizes = camera_params.getSupportedPreviewSizes();
		        Size curr_supported_size = supported_sizes.get(0);
		        for (Size supported_size : supported_sizes) {
		        	if ((supported_size.width*supported_size.height)<
		        			(curr_supported_size.width*curr_supported_size.height)) {
		        		curr_supported_size = supported_size;
		        	}
		        }
		        camera_params.setPreviewSize(curr_supported_size.width,curr_supported_size.height);
		        camera.setParameters(camera_params);
		        camera.setDisplayOrientation(90);
		        
		        // Configure the camera to transmit its preview to the SurfaceView.
		        try {
					camera.setPreviewDisplay(video_holder);
				} catch (IOException e1) {
					e1.printStackTrace();
				}
		        Size preview_size = camera.getParameters().getPreviewSize();
		        int preview_format = camera.getParameters().getPreviewFormat();
		        
		        // Configure the camera preview's callback.
		        int data_buffer_size =(int)(preview_size.height*preview_size.width*
		                               (ImageFormat.getBitsPerPixel(preview_format)/8.0));
		        camera.addCallbackBuffer(new byte[data_buffer_size]);
		        camera.addCallbackBuffer(new byte[data_buffer_size]);
		        camera.addCallbackBuffer(new byte[data_buffer_size]);
		        final Size configured_size = curr_supported_size;
		        camera.setPreviewCallbackWithBuffer(new Camera.PreviewCallback() {
		            private long timestamp=0;
		            public synchronized void onPreviewFrame(byte[] data, Camera camera) {
		            	
		            	// Only send data to queue if the space is available.
		            	if (cam_queue.size()<CAM_QUEUE_MAX) {
			            	ByteBuffer control = ByteBuffer.allocate(CONTROL_SIZE); 
			            	control.putInt(ByteSwapper.swap(CONTROL_SYNCH));
			            	control.putInt(ByteSwapper.swap(CONTROL_CAM));
			            	control.putInt(ByteSwapper.swap(configured_size.width));
			            	control.putInt(ByteSwapper.swap(configured_size.height));
			            	control.putInt(ByteSwapper.swap(data.length));
			            	int last_byte_checksum = (int)data[data.length-1];
			            	control.putInt(ByteSwapper.swap(last_byte_checksum));
			            	cam_queue.add(control.array());
			            	cam_queue.add(data);
		            	}
		                Log.v("CameraTest","Time Gap = "+(System.currentTimeMillis()-timestamp));
		                timestamp=System.currentTimeMillis();
		                try{
		                	// Put the buffer back.
		                    camera.addCallbackBuffer(data);
		                }catch (Exception e) {
		                    Log.e("CameraTest", "addCallbackBuffer error");
		                    return;
		                }
		                return;
		            }
		        });
		        camera.startPreview();
			}
        });
    }
    
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();
        if (id == R.id.action_settings) {
            return true;
        }
        return super.onOptionsItemSelected(item);
    }
    
    @Override 
    public void onDestroy() {
    	
    }
}
